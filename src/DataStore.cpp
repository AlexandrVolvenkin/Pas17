
//-------------------------------------------------------------------------------
//  Source      : FileName.cpp
//  Created     : 01.06.2022
//  Author      : Alexandr Volvenkin
//  email       : aav-36@mail.ru
//  GitHub      : https://github.com/AlexandrVolvenkin
//-------------------------------------------------------------------------------
#include <iostream>
#include <string.h>

#include "Task.h"
#include "Resources.h"
#include "StorageDevice.h"
#include "DataStore.h"
#include "Crc.h"
#include "HammingCodes.h"


// (sizeof(struct TAnalogueInputDescriptionDataBase) * ANALOG_MODULE_INPUT_QUANTITY)// 28х6=168.
#define ANALOGUE_INPUT_MODULE_DATA_BASE_BLOCK_LENGTH 168
// (sizeof(struct TMrXXOneChannelDataBase) * DISCRETE_OUTPUT_MODULE_RELAY_OUTPUT_QUANTITY)// 3х64=192.
#define DISCRETE_OUTPUT_MODULE_DATA_BASE_BLOCK_LENGTH 192
// (sizeof(struct TMbmFunction1234PackOne) * EXTERNAL_MODULE_FUNCTION_1234_QUANTITY) + 1// 13х16=208.
#define MBM_FUNCTION_1234_BLOCK_DATA_BASE_BLOCK_LENGTH (208 + 1)
// (sizeof(struct TMbmFunction15Sourse) * EXTERNAL_MODULE_FUNCTION_15_QUANTITY)// 72х3=216.
#define MBM_FUNCTION_15_BLOCK_DATA_BASE_BLOCK_LENGTH 216
// (sizeof(struct TDiscreteInputDescriptionWork) * DISCRETE_INPUT_SYGNALS_DATA_BASE_BLOCKS_IN_BLOCK_QUANTITY)// 11х18=198.
#define DISCRETE_INPUT_SYGNALS_DATA_BASE_BLOCK_LENGTH 192
// (sizeof(struct TAnalogueOutputRegulatorDescriptionDataBase) * ANALOG_OUTPUT_MODULE_REGULATORS_QUANTITY)// 28х6=168.
#define CURRENT_OUTPUT_MODULE_REGULATOR_DATA_BASE_BLOCK_LENGTH 56
#define CURRENT_OUTPUT_MODULE_PSP_DATA_BASE_BLOCK_LENGTH 56
// DIMENSIONS_PARAMETERS_DATA_BLOCKS_IN_BLOCK_QUANTITY * 6// 6х16=96.
#define DIMENSIONS_PARAMETERS_DATA_BASE_BLOCK_LENGTH 96
// TEXT_TITLES_DATA_BASE_BLOCKS_IN_BLOCK_QUANTITY * TEXT_TITLES_DATA_LENGTH// (384 ТР, 24 блока).
#define TEXT_TITLES_DATA_BASE_BLOCK_LENGTH 224
// (sizeof(struct TFunctionBlockDescriptionWork) * FUNCTION_BLOCK_DATA_BASE_BLOCKS_IN_BLOCK_QUANTITY)// 19х10=190.
#define FUNCTION_BLOCK_DATA_BASE_BLOCK_LENGTH 160// 19х10=190 (120 ФБЛ, 12 блоков)
#define MATHEMATICAL_BLOCK_DATA_BASE_BLOCK_LENGTH 208// 82 – 84 (48 ФБМ, 3 блока 13*16=208 )
#define DISCRETE_INPUT_MODULE_DATA_BASE_BLOCK_LENGTH 32// 2х16=32.
#define NETWORK_ADDRESS_DATA_BASE_BLOCK_LENGTH 1
#define RESERVED_DATA_BASE_BLOCK_LENGTH 1
#define REFERENCE_POINTS_ADC_CODES_DATA_BASE_BLOCK_LENGTH 42

// массив содержит размеры блоков базы данных.
// массив базы данных состоит из 100 блоков по 256 байт.
// когда программатор запрашивает нужный ему блок, (в функции - modbus_reply() - case _FC_DATA_BASE_READ:),
// из этого массива, по номеру, программатору выдаётся размер блока.
const unsigned char aucDataBaseBlockLength[CDataStore::MAX_BLOCKS_NUMBER] =
{
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    ANALOGUE_INPUT_MODULE_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,



    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    DISCRETE_INPUT_SYGNALS_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,



    FUNCTION_BLOCK_DATA_BASE_BLOCK_LENGTH,
    FUNCTION_BLOCK_DATA_BASE_BLOCK_LENGTH,
    FUNCTION_BLOCK_DATA_BASE_BLOCK_LENGTH,
    FUNCTION_BLOCK_DATA_BASE_BLOCK_LENGTH,
    FUNCTION_BLOCK_DATA_BASE_BLOCK_LENGTH,
    FUNCTION_BLOCK_DATA_BASE_BLOCK_LENGTH,
    FUNCTION_BLOCK_DATA_BASE_BLOCK_LENGTH,
    FUNCTION_BLOCK_DATA_BASE_BLOCK_LENGTH,
    FUNCTION_BLOCK_DATA_BASE_BLOCK_LENGTH,
    FUNCTION_BLOCK_DATA_BASE_BLOCK_LENGTH,



    FUNCTION_BLOCK_DATA_BASE_BLOCK_LENGTH,
    FUNCTION_BLOCK_DATA_BASE_BLOCK_LENGTH,
    CURRENT_OUTPUT_MODULE_REGULATOR_DATA_BASE_BLOCK_LENGTH,
    CURRENT_OUTPUT_MODULE_PSP_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    DIMENSIONS_PARAMETERS_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,



    TEXT_TITLES_DATA_BASE_BLOCK_LENGTH,
    TEXT_TITLES_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,



    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,



    REFERENCE_POINTS_ADC_CODES_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,


    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,



    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,



    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    RESERVED_DATA_BASE_BLOCK_LENGTH,
    NETWORK_ADDRESS_DATA_BASE_BLOCK_LENGTH
};

//-------------------------------------------------------------------------------
CDataStore::CDataStore()
{
    m_puiIntermediateBuff = new uint8_t[MAX_ENCODED_BLOCK_LENGTH];
    SetFsmState(IDDLE);
//    SetSavedFsmState(IDDLE);
}

//-------------------------------------------------------------------------------
CDataStore::CDataStore(CStorageDeviceInterface* pxStorageDevice) :
    m_pxStorageDevice(pxStorageDevice)
{
    m_puiIntermediateBuff = new uint8_t[MAX_ENCODED_BLOCK_LENGTH];
    SetFsmState(IDDLE);
//    SetSavedFsmState(IDDLE);
}

//-------------------------------------------------------------------------------
CDataStore::~CDataStore()
{
    delete m_puiIntermediateBuff;
    delete m_pxStorageDevice;

}

//-------------------------------------------------------------------------------
void CDataStore::SetStorageDeviceName(std::string sName)
{
    m_sStorageDeviceName = sName;
}

//-------------------------------------------------------------------------------
void CDataStore::SetStorageDevice(CStorageDeviceInterface* pxStorageDevice)
{
    m_pxStorageDevice = pxStorageDevice;
}

////-------------------------------------------------------------------------------
//void CDataStore::SetResources(CResources* pxResources)
//{
//    m_pxResources = pxResources;
//}
//
////-------------------------------------------------------------------------------
//CResources* CDataStore::GetResources(void)
//{
//    return m_pxResources;
//}

//-------------------------------------------------------------------------------
void CDataStore::CreateServiceSection(void)
{
    SetFsmState(IDDLE);

    // Очистим служебный контекст.
    memset(reinterpret_cast<uint8_t*>(&m_xServiseSection.xServiseSectionData),
           0,
           sizeof(struct TServiseSectionData));

    // Установим размер первичных данных.
    m_xServiseSection.xServiseSectionData.uiLength = sizeof(struct TServiseSectionData);
    // Количество байт служебного контекста
    // должно быть известно заранее.
    // Так как по нему извлекаются начальные данные.
    // Используется самовосстанавливающийся код Хемминга(8,4).
    // Коэффициент - 1.5: один байт преобразуется в кодовое слово 12 бит,
    // из двух байт полезных данных получается три байта кодированных.
    // Установим размер закодированных данных.
    m_xServiseSection.xServiseSectionData.uiEncodedLength =
        (CHammingCodes::CalculateEncodedDataLength(sizeof(struct TServiseSection)));
    // Установим смещение на начало данных блоков.
    m_xServiseSection.xServiseSectionData.uiFreeSpaceOffset =
        (SERVICE_SECTION_DATA_BEGIN +
         m_xServiseSection.xServiseSectionData.uiEncodedLength);
    // Хранилище пусто.
    m_xServiseSection.xServiseSectionData.uiStoredBlocksNumber = 0;
    // Установим признак - хранилище не подписано.
    m_xServiseSection.xServiseSectionData.uiCrcOfBlocksCrc = 0;
}

//-------------------------------------------------------------------------------
// Готовит данные временного служебного блока к записи.
// Кодирует по алгоритму Хемминга и
// передаёт автомату записи устройства хранения.
uint8_t CDataStore::TemporaryServiceSectionWritePrepare(void)
{
    // Вычислим контрольную сумму.
    m_xServiseSection.uiCrc =
        usCrc16(reinterpret_cast<uint8_t*>(&m_xServiseSection.xServiseSectionData),
                sizeof(struct TServiseSectionData));

    // Звкодируем данные алгоритмом Хемминга.
    uint16_t uiEncodedByteCounter =
        CHammingCodes::BytesToHammingCodes(m_puiIntermediateBuff,
                                           reinterpret_cast<uint8_t*>(&m_xServiseSection),
                                           sizeof(struct TServiseSection));

    if (m_pxStorageDevice -> WriteBlock(m_puiIntermediateBuff,
                                        TEMPORARY_SERVICE_SECTION_DATA_BEGIN,
                                        uiEncodedByteCounter))
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

//-------------------------------------------------------------------------------
// Готовит данные служебного блока к записи.
// Кодирует по алгоритму Хемминга и
// передаёт автомату записи устройства хранения.
uint8_t CDataStore::ServiceSectionWritePrepare(void)
{
    // Вычислим контрольную сумму.
    m_xServiseSection.uiCrc =
        usCrc16(reinterpret_cast<uint8_t*>(&m_xServiseSection.xServiseSectionData),
                sizeof(struct TServiseSectionData));

    // Звкодируем данные алгоритмом Хемминга.
    uint16_t uiEncodedByteCounter =
        CHammingCodes::BytesToHammingCodes(m_puiIntermediateBuff,
                                           reinterpret_cast<uint8_t*>(&m_xServiseSection),
                                           sizeof(struct TServiseSection));

    if (m_pxStorageDevice -> WriteBlock(m_puiIntermediateBuff,
                                        SERVICE_SECTION_DATA_BEGIN,
                                        uiEncodedByteCounter))
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

//-------------------------------------------------------------------------------
// Считывает и проверяет целостность временного служебного блока.
uint8_t CDataStore::ReadTemporaryServiceSection(void)
{
    uint16_t uiEncodedLength =
        (CHammingCodes::CalculateEncodedDataLength(sizeof(struct TServiseSection)));

    // Прочитаем закодированные данные.
    // При чтении данных возникла ошибка?
    if (!(m_pxStorageDevice -> ReadBlock(m_puiIntermediateBuff,
                                         TEMPORARY_SERVICE_SECTION_DATA_BEGIN,
                                         uiEncodedLength)))
    {
        // Нет данных.
        return 0;
    }

    // Декодируем прочитанные данные.
    CHammingCodes::HammingCodesToBytes(reinterpret_cast<uint8_t*>(&m_xServiseSection),
                                       m_puiIntermediateBuff,
                                       uiEncodedLength);

    // Блок не повреждён?
    if (m_xServiseSection.uiCrc ==
            usCrc16(reinterpret_cast<uint8_t*>(&m_xServiseSection.xServiseSectionData),
                    sizeof(struct TServiseSectionData)))
    {
        return 1;
    }
    else
    {
        // Нет данных.
        return 0;
    }
}

//-------------------------------------------------------------------------------
// Считывает и проверяет целостность служебного блока.
uint8_t CDataStore::ReadServiceSection(void)
{
    uint16_t uiEncodedLength =
        (CHammingCodes::CalculateEncodedDataLength(sizeof(struct TServiseSection)));

    // Прочитаем закодированные данные.
    // При чтении данных возникла ошибка?
    if (!(m_pxStorageDevice -> ReadBlock(m_puiIntermediateBuff,
                                         SERVICE_SECTION_DATA_BEGIN,
                                         uiEncodedLength)))
    {
        // Нет данных.
        return 0;
    }

    // Декодируем прочитанные данные.
    CHammingCodes::HammingCodesToBytes(reinterpret_cast<uint8_t*>(&m_xServiseSection),
                                       m_puiIntermediateBuff,
                                       uiEncodedLength);

    // Блок не повреждён?
    if (m_xServiseSection.uiCrc ==
            usCrc16(reinterpret_cast<uint8_t*>(&m_xServiseSection.xServiseSectionData),
                    sizeof(struct TServiseSectionData)))
    {
        return 1;
    }
    else
    {
        // Нет данных.
        return 0;
    }
}

//-------------------------------------------------------------------------------
// Считывает и проверяет целостность временного буфера блока.
uint8_t CDataStore::CheckTemporaryBlock(void)
{
    uint8_t uiBlock = m_uiBlock;

    // Произошёл выход за границы буфера?
    if (uiBlock >= MAX_BLOCKS_NUMBER)
    {
        // Нет данных.
        return 0;
    }

    uint16_t uiLength;
    uint16_t uiEncodedLength;
    uint16_t uiSourceOffset;

    // Блок существует?
    if ((m_xServiseSection.xServiseSectionData.
            axBlockPositionData[uiBlock].uiLength != 0) &&
            (m_xServiseSection.xServiseSectionData.
             axBlockPositionData[uiBlock].uiEncodedLength != 0))
    {
        // Получим адрес блока в EEPROM.
        uiSourceOffset = m_xServiseSection.xServiseSectionData.
                         axBlockPositionData[uiBlock].uiOffset;
        // Получим размер блока.
        uiLength = m_xServiseSection.xServiseSectionData.
                   axBlockPositionData[uiBlock].uiLength;
        // Получим размер закодированного блока.
        uiEncodedLength = m_xServiseSection.xServiseSectionData.
                          axBlockPositionData[uiBlock].uiEncodedLength;
    }
    else
    {
        // Нет данных.
        return 0;
    }

    // Прочитаем закодированные данные.
    // При чтении данных возникла ошибка?
    if (!(m_pxStorageDevice -> ReadBlock(m_puiIntermediateBuff,
                                         TEMPORARY_BLOCK_DATA_BEGIN,
                                         uiEncodedLength)))
    {
        // Нет данных.
        return 0;
    }

    // Декодируем прочитанные данные.
    CHammingCodes::HammingCodesToBytes(m_puiIntermediateBuff, m_puiIntermediateBuff, uiEncodedLength);

    // Блок не повреждён?
    if (m_xServiseSection.xServiseSectionData.
            axBlockPositionData[uiBlock].uiCrc ==
            usCrc16(m_puiIntermediateBuff, uiLength))
    {
        return 1;
    }
    else
    {
        // Нет данных.
        return 0;
    }
}

//-------------------------------------------------------------------------------
// Считывает и проверяет целостность блока.
uint8_t CDataStore::CheckBlock(void)
{
    uint8_t uiBlock = m_uiBlock;

    // Произошёл выход за границы буфера?
    if (uiBlock >= MAX_BLOCKS_NUMBER)
    {
        // Нет данных.
        return 0;
    }

    uint16_t uiLength;
    uint16_t uiEncodedLength;
    uint16_t uiSourceOffset;

    // Блок существует?
    if ((m_xServiseSection.xServiseSectionData.
            axBlockPositionData[uiBlock].uiLength != 0) &&
            (m_xServiseSection.xServiseSectionData.
             axBlockPositionData[uiBlock].uiEncodedLength != 0))
    {
        // Получим адрес блока в EEPROM.
        uiSourceOffset = m_xServiseSection.xServiseSectionData.
                         axBlockPositionData[uiBlock].uiOffset;
        // Получим размер блока.
        uiLength = m_xServiseSection.xServiseSectionData.
                   axBlockPositionData[uiBlock].uiLength;
        // Получим размер закодированного блока.
        uiEncodedLength = m_xServiseSection.xServiseSectionData.
                          axBlockPositionData[uiBlock].uiEncodedLength;
    }
    else
    {
        // Нет данных.
        return 0;
    }

    // Прочитаем закодированные данные.
    // При чтении данных возникла ошибка?
    if (!(m_pxStorageDevice -> ReadBlock(m_puiIntermediateBuff,
                                         uiSourceOffset,
                                         uiEncodedLength)))
    {
        // Нет данных.
        return 0;
    }

    // Декодируем прочитанные данные.
    CHammingCodes::HammingCodesToBytes(m_puiIntermediateBuff, m_puiIntermediateBuff, uiEncodedLength);

    // Блок не повреждён?
    if (m_xServiseSection.xServiseSectionData.
            axBlockPositionData[uiBlock].uiCrc ==
            usCrc16(m_puiIntermediateBuff, uiLength))
    {
        return 1;
    }
    else
    {
        // Нет данных.
        return 0;
    }
}

//-------------------------------------------------------------------------------
// Считывает и проверяет целостность блока.
uint16_t CDataStore::ReadBlock(uint8_t *puiDestination, uint8_t uiBlock)
{
    // Произошёл выход за границы буфера?
    if (uiBlock >= MAX_BLOCKS_NUMBER)
    {
        // Нет данных.
        return 0;
    }

    uint16_t uiLength;
    uint16_t uiEncodedLength;
    uint16_t uiSourceOffset;

    // Блок существует?
    if ((m_xServiseSection.xServiseSectionData.
            axBlockPositionData[uiBlock].uiLength != 0) &&
            (m_xServiseSection.xServiseSectionData.
             axBlockPositionData[uiBlock].uiEncodedLength != 0))
    {
        // Получим адрес блока в EEPROM.
        uiSourceOffset = m_xServiseSection.xServiseSectionData.
                         axBlockPositionData[uiBlock].uiOffset;
        // Получим размер блока.
        uiLength = m_xServiseSection.xServiseSectionData.
                   axBlockPositionData[uiBlock].uiLength;
        // Получим размер закодированного блока.
        uiEncodedLength = m_xServiseSection.xServiseSectionData.
                          axBlockPositionData[uiBlock].uiEncodedLength;
    }
    else
    {
        // Нет данных.
        return 0;
    }

    // Прочитаем закодированные данные.
    m_pxStorageDevice -> ReadBlock(m_puiIntermediateBuff, uiSourceOffset, uiEncodedLength);

    // Декодируем прочитанные данные.
    CHammingCodes::HammingCodesToBytes(m_puiIntermediateBuff, m_puiIntermediateBuff, uiEncodedLength);

    // Блок не повреждён?
    if (m_xServiseSection.xServiseSectionData.
            axBlockPositionData[uiBlock].uiCrc ==
            usCrc16(m_puiIntermediateBuff, uiLength))
    {
        memcpy(puiDestination, m_puiIntermediateBuff, uiLength);
        return uiLength;
    }
    else
    {
        // Нет данных.
        return 0;
    }
}

//-------------------------------------------------------------------------------
// Готовит данные блока к записи во временный буфер.
// Кодирует по алгоритму Хемминга, размечает место для хранения и
// передаёт автомату записи устройства хранения.
uint8_t CDataStore::TemporaryBlockWritePrepare(void)
{
    uint8_t uiBlock = m_uiBlock;
    uint8_t* puiSource = m_puiBlockSource;
    uint16_t uiLength = m_uiBlockLength;

    // Звкодируем данные алгоритмом Хемминга.
    uint16_t uiEncodedByteCounter =
        CHammingCodes::BytesToHammingCodes(m_puiIntermediateBuff, puiSource, uiLength);

    // Данные текущего блока данных - uiBlock сохраняются впервые?
    if ((m_xServiseSection.xServiseSectionData.
            axBlockPositionData[uiBlock].uiLength == 0) &&
            (m_xServiseSection.xServiseSectionData.
             axBlockPositionData[uiBlock].uiEncodedLength == 0))
    {
        // Добавили новый блок данных.
        // Сохраним смещение на блок.
        m_xServiseSection.xServiseSectionData.
        axBlockPositionData[uiBlock].uiOffset = m_xServiseSection.xServiseSectionData.uiFreeSpaceOffset;
        // Изменим смещение на свободное место.
        m_xServiseSection.xServiseSectionData.uiFreeSpaceOffset += uiEncodedByteCounter;
        // Сохраним размер первичных данных.
        m_xServiseSection.xServiseSectionData.
        axBlockPositionData[uiBlock].uiLength = uiLength;
        // Сохраним размер закодированных данных.
        m_xServiseSection.xServiseSectionData.
        axBlockPositionData[uiBlock].uiEncodedLength = uiEncodedByteCounter;
        // Увеличим количество блоков находящихся в хранилище.
        m_xServiseSection.xServiseSectionData.uiStoredBlocksNumber += 1;
    }

    // Вычислим контрольную сумму поступивших данных.
    m_xServiseSection.xServiseSectionData.
    axBlockPositionData[uiBlock].uiCrc =
        usCrc16(puiSource, uiLength);

    if (m_pxStorageDevice -> WriteBlock(m_puiIntermediateBuff,
                                        TEMPORARY_BLOCK_DATA_BEGIN,
                                        uiEncodedByteCounter))
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

//-------------------------------------------------------------------------------
// Готовит данные блока к записи.
// Кодирует по алгоритму Хемминга, размечает место для хранения и
// передаёт автомату записи устройства хранения.
uint8_t CDataStore::BlockWritePrepare(void)
{
    uint8_t uiBlock = m_uiBlock;
    uint8_t* puiSource = m_puiBlockSource;
    uint16_t uiLength = m_uiBlockLength;

    // Звкодируем данные алгоритмом Хемминга.
    uint16_t uiEncodedByteCounter =
        CHammingCodes::BytesToHammingCodes(m_puiIntermediateBuff, puiSource, uiLength);

    // Данные текущего блока данных - uiBlock сохраняются впервые?
    if ((m_xServiseSection.xServiseSectionData.
            axBlockPositionData[uiBlock].uiLength == 0) &&
            (m_xServiseSection.xServiseSectionData.
             axBlockPositionData[uiBlock].uiEncodedLength == 0))
    {
        // Добавили новый блок данных.
        // Сохраним смещение на блок.
        m_xServiseSection.xServiseSectionData.
        axBlockPositionData[uiBlock].uiOffset = m_xServiseSection.xServiseSectionData.uiFreeSpaceOffset;
        // Изменим смещение на свободное место.
        m_xServiseSection.xServiseSectionData.uiFreeSpaceOffset += uiEncodedByteCounter;
        // Сохраним размер первичных данных.
        m_xServiseSection.xServiseSectionData.
        axBlockPositionData[uiBlock].uiLength = uiLength;
        // Сохраним размер закодированных данных.
        m_xServiseSection.xServiseSectionData.
        axBlockPositionData[uiBlock].uiEncodedLength = uiEncodedByteCounter;
//        // Увеличим количество блоков находящихся в хранилище.
//        m_xServiseSection.xServiseSectionData.uiStoredBlocksNumber += 1;
    }

    // Вычислим контрольную сумму поступивших данных.
    m_xServiseSection.xServiseSectionData.
    axBlockPositionData[uiBlock].uiCrc =
        usCrc16(puiSource, uiLength);
//    // Сохраним индекс последнего записываемого блока.
//    m_xServiseSection.xServiseSectionData.uiLastWritedBlockNumber = uiBlock;

    if (m_pxStorageDevice -> WriteBlock(m_puiIntermediateBuff,
                                        m_xServiseSection.xServiseSectionData.
                                        axBlockPositionData[uiBlock].uiOffset,
                                        uiEncodedByteCounter))
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

//-------------------------------------------------------------------------------
// Запись блока в хранилище проходит поэтапно.
// 1 - CDataStore::WriteBlock(uint8_t *puiSource, uint16_t uiLength, uint8_t uiBlock).
// 2 - CDataStore::BlockWritePrepare(void).
// 3 - CStorageDevice::WriteBlock(uint16_t uiOffset, uint8_t *puiSource, uint16_t uiLength).

// Передаёт данные контекста записи блока автомату хранилища данных и запускает процесс записи.
uint8_t CDataStore::WriteBlock(uint8_t *puiSource, uint16_t uiLength, uint8_t uiBlock)
{
    // Автомат не готов к записи?
    if ((GetFsmState() != IDDLE) ||
            (GetFsmState() != DATA_WRITED_SUCCESSFULLY) ||
            (GetFsmState() != WRITE_ERROR))
    {
//        SetFsmEvent(WRITE_ERROR_FSM_EVENT);
        return 0;
    }

    // Произошёл выход за границы буфера?
    if (uiBlock >= MAX_BLOCKS_NUMBER)
    {
        // Нет данных.
        return 0;
    }

    // Получим данные контекста записи блока.
    m_puiBlockSource = puiSource;
    m_uiBlockLength = uiLength;
    m_uiBlock = uiBlock;

//    SetFsmEvent(WRITE_IN_PROGRESS_FSM_EVENT);
    // Запустим процесс записи.
    SetFsmState(START_WRITE_TEMPORARY_BLOCK_DATA);
}

//-------------------------------------------------------------------------------
// Вызывается только если база данных подтверждена пользователем.
void CDataStore::CrcOfBlocksCrcCreate(void)
{
    // Контрольная сумма вычисленная из массива контрольных сумм блоков, не включая служебный.
    // Сохраняется при первой и последующих записях любых блоков через программатор.
    // Ноль или её несовпадение свидетельствует о том, что база данных создана по умоланию,
    // и не подтверждена пользователем. В этом случае прибор переходит в режим сигнализации об ошибке,
    // ожидая квитирования или записи базы данных.
    uint16_t auiBlocksCrc[MAX_BLOCKS_NUMBER];

    // Получим Crc всех блоков.
    for (uint16_t i = 0;
            i < MAX_BLOCKS_NUMBER;
            i++)
    {
        auiBlocksCrc[i] =
            m_xServiseSection.xServiseSectionData.axBlockPositionData[i].uiCrc;
    }

    // Сохраним Crc всех блоков.
    m_xServiseSection.xServiseSectionData.uiCrcOfBlocksCrc =
        usCrc16(reinterpret_cast<uint8_t*>(auiBlocksCrc),
                (MAX_BLOCKS_NUMBER * sizeof(uint16_t)));

}

//-------------------------------------------------------------------------------
bool CDataStore::CrcOfBlocksCrcCheck(void)
{
    // Контрольная сумма вычисленная из массива контрольных сумм блоков, не включая служебный.
    // Сохраняется при первой и последующих записях любых блоков через программатор.
    // Ноль или её несовпадение свидетельствует о том, что база данных создана по умоланию,
    // и не подтверждена пользователем. В этом случае прибор переходит в режим сигнализации об ошибке,
    // ожидая квитирования или записи базы данных.
    uint16_t auiBlocksCrc[MAX_BLOCKS_NUMBER];

    // Получим Crc всех блоков.
    for (uint16_t i = 0;
            i < MAX_BLOCKS_NUMBER;
            i++)
    {
        auiBlocksCrc[i] =
            m_xServiseSection.xServiseSectionData.axBlockPositionData[i].uiCrc;
    }

    // Crc из Crc всех блоков совпадает с сохранённым в служебном блоке?
    if (m_xServiseSection.xServiseSectionData.uiCrcOfBlocksCrc ==
            usCrc16(reinterpret_cast<uint8_t*>(auiBlocksCrc),
                    (MAX_BLOCKS_NUMBER * sizeof(uint16_t))))
    {
        return true;
    }
    else
    {
        return false;
    }
}


//-------------------------------------------------------------------------------
uint8_t CDataStore::GetBlockLength(uint8_t uiBlock)
{
//    return m_xServiseSection.xServiseSectionData.
//           axBlockPositionData[uiBlock].uiLength;
    return aucDataBaseBlockLength[uiBlock];
//    return 0;
};

////-------------------------------------------------------------------------------
//// Проверяет целостность данных хранилища.
//// Восстанавлмвает повреждённые данные с помощью алгоритма Хемминга.
//// Восстанавливает данные записываемого блока при сбое питания и т.д.
//uint8_t CDataStore::Check(void)
//{
//    enum
//    {
//        IDDLE = 0,
//
//        TEMPORARY_SERVICE_SECTION_DATA_CHECK,
//        TEMPORARY_SERVICE_SECTION_LINKED_BLOCKS_CHECK,
//
//        CORRUPTED_BLOCK_RECOVERY_WRITE_END_WAITING,
//        SERVICE_SECTION_DATA_WRITE_START,
//        SERVICE_SECTION_DATA_WRITE_END_WAITING,
//
//        SERVICE_SECTION_DATA_CHECK,
//        SERVICE_SECTION_LINKED_BLOCKS_CHECK,
//
//        DATA_STORE_NEW_VERSION_ACCEPTED,
//        DATA_STORE_OLD_VERSION_ACCEPTED,
//
//        DATA_STORE_CHECK_OK,
//        DATA_STORE_CHECK_ERROR,
//        DATA_STORE_CHECK_REPEAT,
//    };
//
//    enum
//    {
//        // Количество попыток восстановления хранилища.
//        RECOVERY_ATTEMPTS_NUMBER = 3,
//    };
//
//    uint8_t uiLocalFsmState;
//    uint8_t uiRecoveryAttemptCounter = 0;
//    uint8_t auiTempArray[MAX_BLOCK_LENGTH];
//
//    // Сбросим ошибки декодирования алгоритмом Хемминга.
//    CHammingCodes::SetErrorCode(CHammingCodes::NONE_ERROR);
//    // Запустим процесс проверки и восстановления хранилища.
//    uiLocalFsmState = TEMPORARY_SERVICE_SECTION_DATA_CHECK;
//
//    while (1)
//    {
//        switch (uiLocalFsmState)
//        {
//        case IDDLE:
//            break;
//
//        case TEMPORARY_SERVICE_SECTION_DATA_CHECK:
//            // Временный служебный блок не повреждён?
//            if (ReadTemporaryServiceSection())
//            {
//                uiLocalFsmState = TEMPORARY_SERVICE_SECTION_LINKED_BLOCKS_CHECK;
//            }
//            else
//            {
//                // Временный служебный блок повреждён, вероятно во время последнего сеанса записи.
//                // Проверим целостность хранилища по постоянному служебному блоку.
//                uiLocalFsmState = SERVICE_SECTION_DATA_CHECK;
//            }
//            break;
//
//        case TEMPORARY_SERVICE_SECTION_LINKED_BLOCKS_CHECK:
//            // Проверим связанность блоков хранилища с временным служебным блоком, а следовательно их целостность.
//            for (uint16_t i = 0;
//                    i < m_xServiseSection.xServiseSectionData.uiStoredBlocksNumber;
//                    i++)
//            {
//                // Блок не связан с временным служебным буфером(или повреждён)?
//                if (!(ReadBlock(auiTempArray, i)))
//                {
//                    // Установим индекс блока, с сохранённым Crc которого,
//                    // будем сравнивать Crc блока сохранённое во временном буфере.
//                    m_uiBlock = i;
//                    // Crc блока из временного буфера совпадает с Crc блока
//                    // сохранённого во временном служебном буфере по текущему индексу?
//                    if (CheckTemporaryBlock())
//                    {
//                        // Скопируем данные блока считанные при проверке во вспомогательный буфер.
//                        memcpy(auiTempArray,
//                               m_puiIntermediateBuff,
//                               m_xServiseSection.xServiseSectionData.
//                               axBlockPositionData[i].uiLength);
//                        // Данные блока успешно записаны во временные буферы,
//                        // но при записи в хранилище произошёл сбой.
//                        // Требуется повторная запись данных блока из временных буферов в хранилище.
//                        WriteBlock(auiTempArray,
//                                   m_xServiseSection.xServiseSectionData.
//                                   axBlockPositionData[i].uiLength,
//                                   i);
//
//                        uiLocalFsmState = CORRUPTED_BLOCK_RECOVERY_WRITE_END_WAITING;
//                        break;
//                    }
//                    else
//                    {
//                        // Блок не связан с временным служебным буфером.
//                        // Возможно произошла ошибка во время записи временного служебного блока.
//                        // Продолжим проверку.
//                        uiLocalFsmState = SERVICE_SECTION_DATA_CHECK;
//                        break;
//                    }
//                }
//                else
//                {
//                    // Блок восстановлен алгоритмом Хемминга после обнаружения ошибки?
//                    if (CHammingCodes::GetErrorCode() != CHammingCodes::NONE_ERROR)
//                    {
//                        // Сбросим ошибки декодирования алгоритмом Хемминга.
//                        CHammingCodes::SetErrorCode(CHammingCodes::NONE_ERROR);
//                        cout << "CHammingCodes::GetErrorCode 1 uiBlock" << (int)i << endl;
//
//                        // Требуется повторная запись данных в хранилище.
//                        WriteBlock(auiTempArray,
//                                   m_xServiseSection.xServiseSectionData.
//                                   axBlockPositionData[i].uiLength,
//                                   i);
//
//                        uiLocalFsmState = CORRUPTED_BLOCK_RECOVERY_WRITE_END_WAITING;
//                        break;
//                    }
//                }
//
//                // Авансом.
//                uiLocalFsmState = SERVICE_SECTION_DATA_WRITE_START;
//            }
//            break;
//
//        case CORRUPTED_BLOCK_RECOVERY_WRITE_END_WAITING:
//            // Ожидаем окончания записи автоматом хранилища.
//            // Сохранённый во временном буфере блок записан в хранилище?
//            if (GetFsmEvent() == CDataStore::WRITE_OK_FSM_EVENT)
//            {
//                uiLocalFsmState = DATA_STORE_CHECK_REPEAT;
//            }
//            // При записи блока произошла ошибка?
//            else if (GetFsmEvent() == CDataStore::WRITE_ERROR_FSM_EVENT)
//            {
//                uiLocalFsmState = DATA_STORE_CHECK_REPEAT;
//            }
//            break;
//
//        case SERVICE_SECTION_DATA_WRITE_START:
//            // Блоки привязаны к временному служебному блоку, следовательно целы.
//            // Как минимум, последний сеанс записи во временные буферы прощёл успешо.
//            // Не будем проверять целостность и совпадение служебного блока, обновим сразу.
//            // Обновим служебный блок.
//            SetFsmEvent(WRITE_IN_PROGRESS_FSM_EVENT);
//            // Запустим процесс записи служебного блока.
//            SetFsmState(START_WRITE_SERVICE_SECTION_DATA);
//            uiLocalFsmState = SERVICE_SECTION_DATA_WRITE_END_WAITING;
//            break;
//
//        case SERVICE_SECTION_DATA_WRITE_END_WAITING:
//            // Ожидаем окончания записи автоматом хранилища.
//            // Служебный блок записан в хранилище?
//            if (GetFsmEvent() == CDataStore::WRITE_OK_FSM_EVENT)
//            {
//                // Служебный блок не повреждён?
//                if (ReadServiceSection())
//                {
//                    uiLocalFsmState = DATA_STORE_NEW_VERSION_ACCEPTED;
//                }
//                else
//                {
//                    uiLocalFsmState = DATA_STORE_CHECK_REPEAT;
//                }
//            }
//            // При записи блока произошла ошибка?
//            else if (GetFsmEvent() == CDataStore::WRITE_ERROR_FSM_EVENT)
//            {
//                uiLocalFsmState = DATA_STORE_CHECK_REPEAT;
//            }
//            break;
//
//        case SERVICE_SECTION_DATA_CHECK:
//            // Мы здесь если временный служебный блок не связан с данными хранимых блоков(или повреждён).
//            // Произошёл сбой во время записи. Попытаемся вернуть предыдущее состояние хранилища.
//            // Служебный блок не повреждён?
//            if (ReadServiceSection())
//            {
//                uiLocalFsmState = SERVICE_SECTION_LINKED_BLOCKS_CHECK;
//            }
//            else
//            {
//                uiLocalFsmState = DATA_STORE_CHECK_ERROR;
//            }
//            break;
//
//        case SERVICE_SECTION_LINKED_BLOCKS_CHECK:
//            // Проверим связанность блоков хранилища со служебным блоком, а следовательно их целостность.
//            for (uint16_t i = 0;
//                    i < m_xServiseSection.xServiseSectionData.uiStoredBlocksNumber;
//                    i++)
//            {
//                // Блок не связан со служебным буфером(или повреждён)?
//                if (!(ReadBlock(auiTempArray, i)))
//                {
//                    // Блок не связан со служебным буфером.
//                    // Возможно произошла ошибка во время записи служебного блока.
//                    // Восстановить данные нельзя.
//                    uiLocalFsmState = DATA_STORE_CHECK_ERROR;
//                    break;
//                }
//                else
//                {
//                    // Блок восстановлен алгоритмом Хемминга после обнаружения ошибки?
//                    if (CHammingCodes::GetErrorCode() != CHammingCodes::NONE_ERROR)
//                    {
//                        // Сбросим ошибки декодирования алгоритмом Хемминга.
//                        CHammingCodes::SetErrorCode(CHammingCodes::NONE_ERROR);
//                        cout << "CHammingCodes::GetErrorCode 2 uiBlock" << (int)i << endl;
//
//                        // Требуется повторная запись данных в хранилище.
//                        WriteBlock(auiTempArray,
//                                   m_xServiseSection.xServiseSectionData.
//                                   axBlockPositionData[i].uiLength,
//                                   i);
//
//                        uiLocalFsmState = CORRUPTED_BLOCK_RECOVERY_WRITE_END_WAITING;
//                        break;
//                    }
//                }
//
//                // Авансом.
//                // Блоки привязаны к служебному блоку, следовательно целы.
//                // Восстановим предыдущую копию хранилища.
//                uiLocalFsmState = DATA_STORE_OLD_VERSION_ACCEPTED;
//            }
//            break;
//
//        case DATA_STORE_NEW_VERSION_ACCEPTED:
//            // Хранилище обновлено.
//            cerr << "DATA_STORE_NEW_VERSION_ACCEPTED" << endl;
//            return 1;
//            break;
//
//        case DATA_STORE_OLD_VERSION_ACCEPTED:
//            // Хранилище не обновлено.
//            cerr << "DATA_STORE_OLD_VERSION_ACCEPTED" << endl;
//            return 1;
//            break;
//
//        case DATA_STORE_CHECK_OK:
//            return 1;
//            break;
//
//        case DATA_STORE_CHECK_ERROR:
//            // Хранилище повреждено.
//            cerr << "DATA_STORE_CHECK_ERROR" << endl;
//            return 0;
//            break;
//
//        case DATA_STORE_CHECK_REPEAT:
//            // Продолжим проверку и попытки восстановления.
//            // Ещё есть возможность для восстановления?
//            if (uiRecoveryAttemptCounter < RECOVERY_ATTEMPTS_NUMBER)
//            {
//                uiRecoveryAttemptCounter++;
//                // Повторим проверку хранилища после восстановления.
//                uiLocalFsmState = TEMPORARY_SERVICE_SECTION_DATA_CHECK;
//            }
//            else
//            {
//                uiLocalFsmState = DATA_STORE_CHECK_ERROR;
//            }
//            break;
//
//        default:
//            return 0;
//            break;
//        }
//
//        Fsm();
//    }
//}

//-------------------------------------------------------------------------------
// Главный автомат записи хранилища.
uint8_t CDataStore::Fsm(void)
{
    switch (GetFsmState())
    {
    case IDDLE:
        break;

    case START:
        std::cout << "CDataStore::Fsm START"  << std::endl;
        std::cout << "CDataStore::Fsm m_sStorageDeviceName" << " " << (m_sStorageDeviceName) << std::endl;
        SetStorageDevice((CStorageDeviceInterface*)
                         (GetResources() ->
                          GetCommonTaskFromMapPointer(m_sStorageDeviceName)));
        SetFsmState(READY);
        break;

    case READY:
        std::cout << "CDataStore::Fsm READY"  << std::endl;
        break;

    case STOP:
        std::cout << "CDataStore::Fsm STOP"  << std::endl;
        break;


//-------------------------------------------------------------------------------
    // Запись блока во временный буфер.
    case START_WRITE_TEMPORARY_BLOCK_DATA:
//        SetFsmEvent(WRITE_IN_PROGRESS_FSM_EVENT);
//        // Установим время ожидания готовности к записи.
//        GetTimerPointer() -> Set(READY_TO_WRITE_WAITING_TIMEOUT);
        SetFsmState(READY_TO_WRITE_WAITING_TEMPORARY_BLOCK_DATA);
        break;

    case READY_TO_WRITE_WAITING_TEMPORARY_BLOCK_DATA:
//        // Устройство хранения готово к записи?
////        if (m_pxStorageDevice -> IsReadyToWrite())
//        if (m_pxStorageDevice -> Fsm() == CStorageDeviceInterface::IDDLE)
//        {
        // Установим время ожидания окончания записи.
        GetTimerPointer() -> Set(WRITE_END_WAITING_TIMEOUT);
//            // Сбросим флаг - запись закончена.
//            m_pxStorageDevice -> SetIsDataWrited(false);
        // Подготовка к записи во временный буфер прошла успешно?
        if (TemporaryBlockWritePrepare())
        {
            SetFsmState(WRITE_END_WAITING_TEMPORARY_BLOCK_DATA);
        }
        else
        {
//                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
            SetFsmState(WRITE_ERROR);
        }
//        }
//        // Время ожидания готовности к записи закончилось?
//        else if (GetTimerPointer() -> IsOverflow())
//        {
////                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
//            SetFsmState(WRITE_ERROR);
//        }
        break;

    case WRITE_END_WAITING_TEMPORARY_BLOCK_DATA:
        // Ожидаем окончания записи автоматом устройства хранения.
        // Устройство хранения закончило запись?
//        if (m_pxStorageDevice -> IsDataWrited())
        if (m_pxStorageDevice -> Fsm() ==
                CStorageDeviceInterface::DATA_WRITED_SUCCESSFULLY)
        {
            m_pxStorageDevice -> SetFsmState(CStorageDeviceInterface::IDDLE);
            // Запись прошла успешно?
            if (CheckTemporaryBlock())
            {
                cerr << "CheckTemporaryBlock ok" << endl;
                SetFsmState(START_WRITE_TEMPORARY_SERVICE_SECTION_DATA);
            }
            else
            {
                cerr << "CheckTemporaryBlock error" << endl;
//                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
                SetFsmState(WRITE_ERROR);
            }
        }
        // Время ожидания окончания записи закончилось?
        else if (GetTimerPointer() -> IsOverflow())
        {
            m_pxStorageDevice -> SetFsmState(CStorageDeviceInterface::IDDLE);
//                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
            SetFsmState(WRITE_ERROR);
        }
        break;


//-------------------------------------------------------------------------------
    // Запись временного служеьного блока.
    case START_WRITE_TEMPORARY_SERVICE_SECTION_DATA:
//        SetFsmEvent(WRITE_IN_PROGRESS_FSM_EVENT);
//        // Установим время ожидания готовности к записи.
//        GetTimerPointer() -> Set(READY_TO_WRITE_WAITING_TIMEOUT);
        SetFsmState(READY_TO_WRITE_WAITING_TEMPORARY_SERVICE_SECTION_DATA);
        break;

    case READY_TO_WRITE_WAITING_TEMPORARY_SERVICE_SECTION_DATA:
//        // Устройство хранения готово к записи?
////        if (m_pxStorageDevice -> IsReadyToWrite())
//        if (m_pxStorageDevice -> Fsm() == CStorageDeviceInterface::IDDLE)
//        {
        // Установим время ожидания окончания записи.
        GetTimerPointer() -> Set(WRITE_END_WAITING_TIMEOUT);
//            // Сбросим флаг - запись закончена.
//            m_pxStorageDevice -> SetIsDataWrited(false);
        // Подготовка к записи прошла успешно?
        if (TemporaryServiceSectionWritePrepare())
        {
            SetFsmState(WRITE_END_WAITING_TEMPORARY_SERVICE_SECTION_DATA);
        }
        else
        {
//                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
            SetFsmState(WRITE_ERROR);
        }
//        }
//        // Время ожидания готовности к записи закончилось?
//        else if (GetTimerPointer() -> IsOverflow())
//        {
////                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
//            SetFsmState(WRITE_ERROR);
//        }
        break;

    case WRITE_END_WAITING_TEMPORARY_SERVICE_SECTION_DATA:
        // Ожидаем окончания записи автоматом устройства хранения.
        // Устройство хранения закончило запись?
//        if (m_pxStorageDevice -> IsDataWrited())
        if (m_pxStorageDevice -> Fsm() ==
                CStorageDeviceInterface::DATA_WRITED_SUCCESSFULLY)
        {
            m_pxStorageDevice -> SetFsmState(CStorageDeviceInterface::IDDLE);
            // Запись прошла успешно?
            if (ReadTemporaryServiceSection())
            {
                cerr << "ReadTemporaryServiceSection ok" << endl;
                SetFsmState(START_WRITE_BLOCK_DATA);
            }
            else
            {
                cerr << "ReadTemporaryServiceSection error" << endl;
//                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
                SetFsmState(WRITE_ERROR);
            }
        }
        // Время ожидания окончания записи закончилось?
        else if (GetTimerPointer() -> IsOverflow())
        {
            m_pxStorageDevice -> SetFsmState(CStorageDeviceInterface::IDDLE);
//                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
            SetFsmState(WRITE_ERROR);
        }
        break;


//-------------------------------------------------------------------------------
    // Запись блока.
    case START_WRITE_BLOCK_DATA:
//        // Установим время ожидания готовности к записи.
//        GetTimerPointer() -> Set(READY_TO_WRITE_WAITING_TIMEOUT);
        SetFsmState(READY_TO_WRITE_WAITING_BLOCK_DATA);
        break;

    case READY_TO_WRITE_WAITING_BLOCK_DATA:
//        // Устройство хранения готово к записи?
////        if (m_pxStorageDevice -> IsReadyToWrite())
//        if (m_pxStorageDevice -> Fsm() == CStorageDeviceInterface::IDDLE)
//        {
        // Установим время ожидания окончания записи записи.
        GetTimerPointer() -> Set(WRITE_END_WAITING_TIMEOUT);
//            // Сбросим флаг - запись закончена.
//            m_pxStorageDevice -> SetIsDataWrited(false);
        // Подготовка к записи прошла успешно?
        if (BlockWritePrepare())
        {
            SetFsmState(WRITE_END_WAITING_BLOCK_DATA);
        }
        else
        {
//                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
            SetFsmState(WRITE_ERROR);
        }
//        }
//        // Время ожидания готовности к записи закончилось?
//        else if (GetTimerPointer() -> IsOverflow())
//        {
////                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
//            SetFsmState(WRITE_ERROR);
//        }
        break;

    case WRITE_END_WAITING_BLOCK_DATA:
        // Ожидаем окончания записи автоматом устройства хранения.
        // Устройство хранения закончило запись?
//        if (m_pxStorageDevice -> IsDataWrited())
        if (m_pxStorageDevice -> Fsm() ==
                CStorageDeviceInterface::DATA_WRITED_SUCCESSFULLY)
        {
            m_pxStorageDevice -> SetFsmState(CStorageDeviceInterface::IDDLE);
            // Запись прошла успешно?
            if (CheckBlock())
            {
                cerr << "CheckBlock ok" << endl;
                SetFsmState(START_WRITE_SERVICE_SECTION_DATA);
            }
            else
            {
                cerr << "CheckBlock error" << endl;
//                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
                SetFsmState(WRITE_ERROR);
            }
        }
        // Время ожидания окончания записи закончилось?
        else if (GetTimerPointer() -> IsOverflow())
        {
            m_pxStorageDevice -> SetFsmState(CStorageDeviceInterface::IDDLE);
//                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
            SetFsmState(WRITE_ERROR);
        }
        break;


//-------------------------------------------------------------------------------
    // Запись служеьного блока.
    case START_WRITE_SERVICE_SECTION_DATA:
//        SetFsmEvent(WRITE_IN_PROGRESS_FSM_EVENT);
//        // Установим время ожидания готовности к записи.
//        GetTimerPointer() -> Set(READY_TO_WRITE_WAITING_TIMEOUT);
        SetFsmState(READY_TO_WRITE_WAITING_SERVICE_SECTION_DATA);
        break;

    case READY_TO_WRITE_WAITING_SERVICE_SECTION_DATA:
//        // Устройство хранения готово к записи?
////        if (m_pxStorageDevice -> IsReadyToWrite())
//        if (m_pxStorageDevice -> Fsm() == CStorageDeviceInterface::IDDLE)
//        {
        // Установим время ожидания окончания записи.
        GetTimerPointer() -> Set(WRITE_END_WAITING_TIMEOUT);
//            // Сбросим флаг - запись закончена.
//            m_pxStorageDevice -> SetIsDataWrited(false);
        // Подготовка к записи прошла успешно?
        if (ServiceSectionWritePrepare())
        {
            SetFsmState(WRITE_END_WAITING_SERVICE_SECTION_DATA);
        }
        else
        {
//                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
            SetFsmState(WRITE_ERROR);
        }
//        }
//        // Время ожидания готовности к записи закончилось?
//        else if (GetTimerPointer() -> IsOverflow())
//        {
////                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
//            SetFsmState(WRITE_ERROR);
//        }
        break;

    case WRITE_END_WAITING_SERVICE_SECTION_DATA:
        // Ожидаем окончания записи автоматом устройства хранения.
        // Устройство хранения закончило запись?
//        if (m_pxStorageDevice -> IsDataWrited())
        if (m_pxStorageDevice -> Fsm() ==
                CStorageDeviceInterface::DATA_WRITED_SUCCESSFULLY)
        {
            m_pxStorageDevice -> SetFsmState(CStorageDeviceInterface::IDDLE);
            // Запись прошла успешно?
            if (ReadServiceSection())
            {
                cerr << "ReadServiceSection ok" << endl;
//                SetFsmEvent(WRITE_OK_FSM_EVENT);
                SetFsmState(DATA_WRITED_SUCCESSFULLY);
            }
            else
            {
                cerr << "ReadServiceSection error" << endl;
//                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
                SetFsmState(WRITE_ERROR);
            }
        }
        // Время ожидания окончания записи закончилось?
        else if (GetTimerPointer() -> IsOverflow())
        {
            m_pxStorageDevice -> SetFsmState(CStorageDeviceInterface::IDDLE);
//                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
            SetFsmState(WRITE_ERROR);
        }
        break;

    case DATA_WRITED_SUCCESSFULLY:
        break;

    case WRITE_ERROR:
        break;

    default:
//                SetFsmEvent(WRITE_ERROR_FSM_EVENT);
        SetFsmState(WRITE_ERROR);
        break;
    }

    return GetFsmState();
}

//-------------------------------------------------------------------------------











